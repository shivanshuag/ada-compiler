# -----------------------------------------------------------------------------
# typecheck.py
#
# Semantic analysis on the ast generated by the parser
# -----------------------------------------------------------------------------
import sys
from ast import *
from datatypes import *
from symbol import *

import adalex
import adaparse

class typecheck():
	Int = Integer()
	Float = Float()
	Str = String()
	Bool = Boolean()
	table_first = symtable(None)
	table_current = table_first

	def check_goal_symbol(self,node):
		self.check_compilation(node.compilation)

	def check_compilation(self, node):
		for comp_unit in node.comp_unit
			self.check_comp_unit(comp_unit)

	def check_comp_unit(self,node):
		node.table = symtable(self.table_current)
		self.table_current = node.table
		for statement in node.statements.statements
			function_name = 'check_' + node.__class__.__name__
      function = getattr(self, function_name)
      function(statement)
      #TODO add to symtable

  def check_AssignmentStatement(self,node):
    table_entry = self.table_current.lookup(node.location.name)
    if not table_entry:
      error(node.lineno, "name '{}' not defined".format(node.location.name))
      return
    if table_entry.typename.check_type == EnumType :
      if node.expr.location.name not in table_entry.length.enum_id :
      error(node.lineno,"Not an enum values")
      else :
     	  if isinstance(node.expr,list):
                for e in node.expr :
                    self.visit(e)
                if len(node.expr) != len((sym.length.record_def)[0].comp_decls) :
                    error(node.lineno, "Length does not match")
                else :
                    for i in range(0,len(node.expr)):
                        if ((sym.length.record_def)[0].comp_decls)[i].typename.check_type != (node.expr)[i].check_type :
                            error(node.lineno, "Type doesn't match")
            else :
                self.visit(node.expr)
        if isinstance(sym, VarDeclaration):
            if hasattr(sym, "check_type") and hasattr(node.expr, "check_type"):
                declared_type = sym.check_type
                value_type = node.expr.check_type
                if declared_type != value_type:
                    error(node.lineno, "Cannot assign {} to {}".format(value_type.typename, declared_type.typename))
                    return
        if hasattr(node.location, "check_type") and hasattr(node.expr, "check_type"):
            declared_type = node.location.check_type
            value_type = node.expr.check_type
            if declared_type != value_type:
                error(node.lineno, "Cannot assign {} to {}".format(value_type.typename, declared_type.typename))



def main():
	global DEBUG
  if(len(sys.argv) > 2):
    DEBUG = 1
  fileName = sys.argv[1]
  f = open(fileName, 'r')
  parser = make_parser()
  tree = parser.parse(f.read())
  typechecker = new typecheck()
  typechecker.check(tree)

DEBUG = 0
lexer = adalex.make_lexer()
tokens = adalex.tokens
if __name__ == '__main__':
	main()